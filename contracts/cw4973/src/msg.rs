use cosmwasm_schema::cw_serde;
use cosmwasm_std::Empty;
use cw721_base::msg::QueryMsg as Cw721QueryMsg;
use crate::state::PermitSignature;

#[cw_serde]
pub struct InstantiateMsg {
    pub admin: Option<String>,
    pub name: String,
    pub symbol: String,
    pub minter: String,
}

#[cw_serde]
pub enum QueryMsg {
    Admin {},
    OwnerOf {
        token_id: String,
        include_expired: Option<bool>,
    },
    Approval {
        token_id: String,
        spender: String,
        include_expired: Option<bool>,
    },
    Approvals {
        token_id: String,
        include_expired: Option<bool>,
    },
    AllOperators {
        owner: String,
        include_expired: Option<bool>,
        start_after: Option<String>,
        limit: Option<u32>,
    },
    NumTokens {},
    ContractInfo {},
    NftInfo {
        token_id: String,
    },
    AllNftInfo {
        token_id: String,
        include_expired: Option<bool>,
    },
    Tokens {
        owner: String,
        start_after: Option<String>,
        limit: Option<u32>,
    },
    AllTokens {
        start_after: Option<String>,
        limit: Option<u32>,
    },
    Minter {},
}

impl From<QueryMsg> for Cw721QueryMsg<Empty> {
    fn from(msg: QueryMsg) -> Cw721QueryMsg<Empty> {
        match msg {
            QueryMsg::OwnerOf {
                token_id,
                include_expired,
            } => Cw721QueryMsg::OwnerOf {
                token_id,
                include_expired,
            },
            QueryMsg::NumTokens {} => Cw721QueryMsg::NumTokens {},
            QueryMsg::ContractInfo {} => Cw721QueryMsg::ContractInfo {},
            QueryMsg::NftInfo { token_id } => Cw721QueryMsg::NftInfo { token_id },
            QueryMsg::AllNftInfo {
                token_id,
                include_expired,
            } => Cw721QueryMsg::AllNftInfo {
                token_id,
                include_expired,
            },
            QueryMsg::Tokens {
                owner,
                start_after,
                limit,
            } => Cw721QueryMsg::Tokens {
                owner,
                start_after,
                limit,
            },
            QueryMsg::AllTokens { start_after, limit } => {
                Cw721QueryMsg::AllTokens { start_after, limit }
            }
            QueryMsg::Minter {} => Cw721QueryMsg::Minter {},
            _ => unreachable!("cannot convert {:?} to Cw721QueryMsg", msg),
        }
    }
}

#[cw_serde]
pub struct AdminResponse {
    pub admin: Option<String>,
}

#[cw_serde]
pub enum ExecuteMsg {
    /// @notice Creates and transfers the ownership of an ABT from the
    ///  transaction's `msg.sender` to `address to`.
    /// @dev Throws unless `bytes signature` represents an EIP-2098 Compact
    ///  Signature of the EIP-712 structured data hash
    ///  `Agreement(address active,address passive,string tokenURI)` expressing
    ///  `address to`'s explicit agreement to be publicly associated with
    ///  `msg.sender` and `string tokenURI`. A unique `uint256 tokenId` must be
    ///  generated by type-casting the `bytes32` EIP-712 structured data hash to a
    ///  `uint256`. If `bytes signature` is empty or `address to` is a contract,
    ///  an EIP-1271-compatible call to `function isValidSignatureNow(...)` must
    ///  be made to `address to`. A successful execution must result in the
    ///  `event Transfer(msg.sender, to, tokenId)`. Once an ABT exists as an
    ///  `uint256 tokenId` in the contract, `function give(...)` must throw.
    /// @param to The receiver of the ABT.
    /// @param uri A distinct Uniform Resource Identifier (URI) for a given ABT.
    /// @param signature A EIP-2098-compatible Compact Signature of the EIP-712
    ///  structured data hash
    ///  `Agreement(address active,address passive,string tokenURI)` signed by
    ///  `address to`.
    /// @return A unique `uint256 tokenId` generated by type-casting the `bytes32`
    ///  EIP-712 structured data hash to a `uint256`.
    Give{
        to: String,
        uri: String,
        signature: PermitSignature,
    },

    /// @notice Creates and transfers the ownership of an ABT from an
    /// `address from` to the transaction's `msg.sender`.
    /// @dev Throws unless `bytes signature` represents an EIP-2098 Compact
    ///  Signature of the EIP-712 structured data hash
    ///  `Agreement(address active,address passive,string tokenURI)` expressing
    ///  `address from`'s explicit agreement to be publicly associated with
    ///  `msg.sender` and `string tokenURI`. A unique `uint256 tokenId` must be
    ///  generated by type-casting the `bytes32` EIP-712 structured data hash to a
    ///  `uint256`. If `bytes signature` is empty or `address from` is a contract,
    ///  an EIP-1271-compatible call to `function isValidSignatureNow(...)` must
    ///  be made to `address from`. A successful execution must result in the
    ///  emission of an `event Transfer(from, msg.sender, tokenId)`. Once an ABT
    ///  exists as an `uint256 tokenId` in the contract, `function take(...)` must
    ///  throw.
    /// @param from The origin of the ABT.
    /// @param uri A distinct Uniform Resource Identifier (URI) for a given ABT.
    /// @param signature A EIP-2098-compatible Compact Signature of the EIP-712
    ///  structured data hash
    ///  `Agreement(address active,address passive,string tokenURI)` signed by
    ///  `address from`.
    /// @return A unique `uint256 tokenId` generated by type-casting the `bytes32`
    ///  EIP-712 structured data hash to a `uint256`.
    Take{
        from: String,
        uri: String,
        signature: PermitSignature,
    },

    /// @notice Removes the `String token_id` from an account.
    /// @dev Must emit a `event Transfer` with the `address to` field pointing to
    ///  the zero address.
    /// @param token_id The identifier for an ABT.
    UnEquip{ nft_id: String },
}